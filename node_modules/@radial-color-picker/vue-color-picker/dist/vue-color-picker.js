(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global.VueColorPicker = factory());
}(this, (function () { 'use strict';

	var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	var colorWheel_umd = createCommonjsModule(function (module, exports) {
	/**
	 * radial-color-picker/color-wheel v2.0.0
	 *
	 * https://github.com/radial-color-picker/color-wheel
	 *
	 * Copyright (c) 2018-present, Rosen Kanev
	 * Released under the MIT License.
	 */
	(function (global, factory) {
	    module.exports = factory();
	}(commonjsGlobal, (function () {
	    /**
	     * Modified version of Lea Verou's
	     * {@link https://github.com/leaverou/conic-gradient conic-gradient}.
	     *
	     * @example
	     * paintColorWheelToCanvas(document.querySelector('#canvas'), 250);
	     *
	     * @param   {HTMLCanvasElement} canvas Canvas to paint the color wheel
	     * @param   {Number}            size   Color wheel radius in pixels
	     * @returns {HTMLCanvasElement} canvas The passed canvas for easier chaining
	     */
	    function paintColorWheelToCanvas(canvas, size) {
	      var half = size / 2;
	      var radius = Math.sqrt(2) * half;
	      var deg = Math.PI / 180;
	      var pi2 = Math.PI * 2;
	      canvas.width = canvas.height = size;
	      var ctx = canvas.getContext('2d'); // .02: To prevent empty blank line and corresponding moire
	      // only non-alpha colors are cared now

	      var thetaOffset = 0.5 * deg + 0.02; // Transform coordinate system so that angles start from the top left, like in CSS

	      ctx.translate(half, half);
	      ctx.rotate(-Math.PI / 2);
	      ctx.translate(-half, -half);

	      for (var i = 0; i < 360; i += 0.5) {
	        ctx.fillStyle = "hsl(" + i + ", 100%, 50%)";
	        ctx.beginPath();
	        ctx.moveTo(half, half);
	        var beginArg = i * deg;
	        var endArg = Math.min(pi2, beginArg + thetaOffset);
	        ctx.arc(half, half, radius, beginArg, endArg);
	        ctx.closePath();
	        ctx.fill();
	      }

	      return canvas;
	    }

	    return paintColorWheelToCanvas;

	})));
	});

	var rotator_umd = createCommonjsModule(function (module, exports) {
	/**
	 * radial-color-picker/rotator v2.0.1
	 *
	 * https://github.com/radial-color-picker/rotator
	 *
	 * Copyright (c) 2018-present, Rosen Kanev
	 * Released under the MIT License.
	 */
	(function (global, factory) {
	  module.exports = factory();
	}(commonjsGlobal, function () {
	  function _defineProperties(target, props) {
	    for (var i = 0; i < props.length; i++) {
	      var descriptor = props[i];
	      descriptor.enumerable = descriptor.enumerable || false;
	      descriptor.configurable = true;
	      if ("value" in descriptor) descriptor.writable = true;
	      Object.defineProperty(target, descriptor.key, descriptor);
	    }
	  }

	  function _createClass(Constructor, protoProps, staticProps) {
	    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
	    if (staticProps) _defineProperties(Constructor, staticProps);
	    return Constructor;
	  }

	  var TO_DEGREES = 180 / Math.PI;
	  var normalizeAngle = function normalizeAngle(angle) {
	    var mod = angle % 360;
	    return mod < 0 ? 360 + mod : mod;
	  };
	  var getRotationFromCoords = function getRotationFromCoords(_ref, rect) {
	    var x = _ref.x,
	        y = _ref.y;
	    var cx = rect.left + rect.width / 2;
	    var cy = rect.top + rect.height / 2;
	    return Math.atan2(y - cy, x - cx) * TO_DEGREES;
	  };
	  var noop = function noop() {};

	  /**
	   * Modified version of Denis Radin's
	   * {@link https://github.com/PixelsCommander/Propeller Propeller}.
	   */

	  var Rotator =
	  /*#__PURE__*/
	  function () {
	    function Rotator(element, options) {
	      this.active = false;
	      this._angle = 0;
	      this.element = element;
	      this.element.style.willChange = 'transform';
	      this.initOptions(options);
	      this.updateCSS();
	      this.bindHandlers();
	      this.addListeners();
	    }

	    var _proto = Rotator.prototype;

	    _proto.initOptions = function initOptions(options) {
	      options = options || {};
	      this.onRotate = options.onRotate || noop;
	      this.onDragStart = options.onDragStart || noop;
	      this.onDragStop = options.onDragStop || noop;
	      this._angle = options.angle || 0;
	    };

	    _proto.bindHandlers = function bindHandlers() {
	      this.onRotationStart = this.onRotationStart.bind(this);
	      this.onRotated = this.onRotated.bind(this);
	      this.onRotationStop = this.onRotationStop.bind(this);
	    };

	    _proto.addListeners = function addListeners() {
	      this.element.addEventListener('touchstart', this.onRotationStart, {
	        passive: true
	      });
	      document.addEventListener('touchmove', this.onRotated, {
	        passive: false
	      });
	      document.addEventListener('touchend', this.onRotationStop, {
	        passive: true
	      });
	      document.addEventListener('touchcancel', this.onRotationStop, {
	        passive: true
	      });
	      this.element.addEventListener('mousedown', this.onRotationStart, {
	        passive: true
	      });
	      document.addEventListener('mousemove', this.onRotated, {
	        passive: false
	      });
	      document.addEventListener('mouseup', this.onRotationStop, {
	        passive: true
	      });
	      document.addEventListener('mouseleave', this.onRotationStop, {
	        passive: false
	      });
	    };

	    _proto.removeListeners = function removeListeners() {
	      this.element.removeEventListener('touchstart', this.onRotationStart);
	      document.removeEventListener('touchmove', this.onRotated);
	      document.removeEventListener('touchend', this.onRotationStop);
	      document.removeEventListener('touchcancel', this.onRotationStop);
	      this.element.removeEventListener('mousedown', this.onRotationStart);
	      document.removeEventListener('mousemove', this.onRotated);
	      document.removeEventListener('mouseup', this.onRotationStop);
	      document.removeEventListener('mouseleave', this.onRotationStop);
	    };

	    _proto.destroy = function destroy() {
	      this.onRotationStop();
	      this.removeListeners();
	    };

	    _proto.onRotationStart = function onRotationStart(event) {
	      if (event.type === 'touchstart' || event.button === 0) {
	        this.initDrag();
	        this.onDragStart(event);
	      }
	    };

	    _proto.onRotationStop = function onRotationStop() {
	      if (this.active) {
	        this.active = false;
	        this.onDragStop();
	      }

	      this.active = false;
	    };

	    _proto.onRotated = function onRotated(event) {
	      if (this.active) {
	        event.preventDefault();
	        var point = event.targetTouches ? event.targetTouches[0] : event;
	        this.updateAngleToMouse({
	          x: point.clientX,
	          y: point.clientY
	        });
	        this.updateCSS();
	        this.onRotate(this._angle);
	      }
	    };

	    _proto.setAngleFromEvent = function setAngleFromEvent(ev) {
	      var newAngle = getRotationFromCoords({
	        x: ev.clientX,
	        y: ev.clientY
	      }, this.element.getBoundingClientRect()); // atan2 gives values between -180 to 180 deg
	      // add 90 degrees offset so that it starts from 0 deg (or red)
	      // and then normalize negative values

	      this._angle = normalizeAngle(newAngle + 90);
	      this.updateCSS();
	      this.onRotate(this._angle);
	    };

	    _proto.updateAngleToMouse = function updateAngleToMouse(newPoint) {
	      var newMouseAngle = getRotationFromCoords(newPoint, this.element.getBoundingClientRect());

	      if (!this.lastMouseAngle) {
	        this.lastElementAngle = this._angle;
	        this.lastMouseAngle = newMouseAngle;
	      }

	      this._angle = normalizeAngle(this.lastElementAngle + newMouseAngle - this.lastMouseAngle);
	    };

	    _proto.initDrag = function initDrag() {
	      this.active = true;
	      this.lastMouseAngle = undefined;
	      this.lastElementAngle = undefined;
	    };

	    _proto.updateCSS = function updateCSS() {
	      this.element.style.transform = "rotate(" + this._angle + "deg)";
	    };

	    _createClass(Rotator, [{
	      key: "angle",
	      get: function get() {
	        return this._angle;
	      },
	      set: function set(value) {
	        if (this._angle !== value) {
	          this._angle = normalizeAngle(value);
	          this.updateCSS();
	        }
	      }
	    }]);

	    return Rotator;
	  }();

	  return Rotator;

	}));
	});

	//
	var script = {
	  rcp: null,
	  name: 'vue-color-picker',
	  props: {
	    hue: {
	      default: 0
	    },
	    saturation: {
	      default: 100
	    },
	    luminosity: {
	      default: 50
	    },
	    alpha: {
	      default: 1
	    },
	    step: {
	      default: 2
	    },
	    mouseScroll: {
	      default: false
	    },
	    variant: {
	      default: 'collapsible' // collapsible | persistent

	    },
	    disabled: {
	      default: false
	    }
	  },

	  data: function data() {
	    return {
	      isPaletteIn: true,
	      isKnobIn: true,
	      isPressed: false,
	      isRippling: false,
	      isDragging: false
	    };
	  },

	  computed: {
	    color: function color() {
	      return ("hsla(" + (this.hue) + ", " + (this.saturation) + "%, " + (this.luminosity) + "%, " + (this.alpha) + ")");
	    }

	  },
	  watch: {
	    hue: function (angle) {
	      this.rcp.angle = angle;
	    }
	  },

	  mounted: function mounted() {
	    var this$1 = this;

	    if (this.mouseScroll) {
	      this.$refs.rotator.addEventListener('wheel', this.onScroll);
	    }

	    var isConicGradientSupported = getComputedStyle(this.$refs.palette).backgroundImage.includes('conic'); // ignore conic-gradient support & polyfill

	    /* istanbul ignore else */

	    if (!isConicGradientSupported) {
	      colorWheel_umd(this.$refs.palette.firstElementChild, this.$el.offsetWidth || 280);
	    }

	    this.rcp = new rotator_umd(this.$refs.rotator, {
	      angle: this.hue,
	      onRotate: this.updateColor,
	      onDragStart: function () {
	        this$1.isDragging = true;
	      },
	      onDragStop: function () {
	        this$1.isDragging = false;
	      }
	    });
	  },

	  methods: {
	    onScroll: function onScroll(ev) {
	      if (this.isPressed || !this.isKnobIn) { return; }
	      ev.preventDefault();

	      if (ev.deltaY > 0) {
	        this.rcp.angle += this.step;
	      } else {
	        this.rcp.angle -= this.step;
	      }

	      this.updateColor(this.rcp.angle);
	    },

	    rotate: function rotate(ev, isIncrementing) {
	      if (this.disabled || this.isPressed || !this.isKnobIn) { return; }
	      var multiplier = isIncrementing ? 1 : -1;

	      if (ev.ctrlKey) {
	        multiplier *= 6;
	      } else if (ev.shiftKey) {
	        multiplier *= 3;
	      }

	      this.rcp.angle += this.step * multiplier;
	      this.updateColor(this.rcp.angle);
	    },

	    updateColor: function updateColor(hue) {
	      this.$emit('input', hue);
	    },

	    rotateToMouse: function rotateToMouse(ev) {
	      if (this.isPressed || !this.isKnobIn) { return; }
	      this.rcp.setAngleFromEvent(ev);
	    },

	    selectColor: function selectColor() {
	      this.isPressed = true;

	      if (this.isPaletteIn && this.isKnobIn) {
	        this.$emit('change', this.hue);
	        this.isRippling = true;
	      } else {
	        this.isPaletteIn = true;
	      }
	    },

	    togglePicker: function togglePicker() {
	      if (this.variant !== 'persistent') {
	        if (this.isKnobIn) {
	          this.isKnobIn = false;
	        } else {
	          this.isKnobIn = true;
	          this.isPaletteIn = true;
	        }
	      }

	      this.isRippling = false;
	      this.isPressed = false;
	    },

	    hidePalette: function hidePalette() {
	      if (!this.isKnobIn) {
	        this.isPaletteIn = false;
	      }
	    }

	  },

	  beforeDestroy: function beforeDestroy() {
	    this.rcp.destroy();
	    this.rcp = null;
	  }

	};

	/* script */
	            var __vue_script__ = script;
	/* template */
	var __vue_render__ = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"rcp",class:{ 'dragging': _vm.isDragging, 'disabled': _vm.disabled },attrs:{"tabindex":_vm.disabled ? -1 : 0},on:{"keyup":function($event){if(!('button' in $event)&&_vm._k($event.keyCode,"enter",13,$event.key,"Enter")){ return null; }return _vm.selectColor($event)},"keydown":[function($event){if(!('button' in $event)&&_vm._k($event.keyCode,"up",38,$event.key,["Up","ArrowUp"])&&_vm._k($event.keyCode,"right",39,$event.key,["Right","ArrowRight"])){ return null; }if('button' in $event && $event.button !== 2){ return null; }$event.preventDefault();_vm.rotate($event, true);},function($event){if(!('button' in $event)&&_vm._k($event.keyCode,"down",40,$event.key,["Down","ArrowDown"])&&_vm._k($event.keyCode,"left",37,$event.key,["Left","ArrowLeft"])){ return null; }if('button' in $event && $event.button !== 0){ return null; }$event.preventDefault();_vm.rotate($event, false);}]}},[_c('div',{ref:"palette",staticClass:"rcp__palette",class:_vm.isPaletteIn ? 'in' : 'out'},[_c('canvas')]),_vm._v(" "),_c('div',{ref:"rotator",staticClass:"rcp__rotator",style:({ 'pointer-events': _vm.disabled || _vm.isPressed || !_vm.isKnobIn ? 'none' : null }),on:{"dblclick":function($event){if($event.target !== $event.currentTarget){ return null; }return _vm.rotateToMouse($event)}}},[_c('div',{staticClass:"rcp__knob",class:_vm.isKnobIn ? 'in' : 'out',on:{"transitionend":_vm.hidePalette}})]),_vm._v(" "),_c('div',{staticClass:"rcp__ripple",class:{ 'rippling': _vm.isRippling },style:({ borderColor: _vm.color })}),_vm._v(" "),_c('button',{staticClass:"rcp__well",class:{ 'pressed': _vm.isPressed },style:({ backgroundColor: _vm.color }),attrs:{"type":"button"},on:{"animationend":_vm.togglePicker,"click":_vm.selectColor}})])};
	var __vue_staticRenderFns__ = [];

	  /* style */
	  var __vue_inject_styles__ = undefined;
	  /* scoped */
	  var __vue_scope_id__ = undefined;
	  /* module identifier */
	  var __vue_module_identifier__ = undefined;
	  /* functional template */
	  var __vue_is_functional_template__ = false;
	  /* component normalizer */
	  function __vue_normalize__(
	    template, style, script$$1,
	    scope, functional, moduleIdentifier,
	    createInjector, createInjectorSSR
	  ) {
	    var component = (typeof script$$1 === 'function' ? script$$1.options : script$$1) || {};

	    // For security concerns, we use only base name in production mode.
	    component.__file = "ColorPicker.vue";

	    if (!component.render) {
	      component.render = template.render;
	      component.staticRenderFns = template.staticRenderFns;
	      component._compiled = true;

	      if (functional) { component.functional = true; }
	    }

	    component._scopeId = scope;

	    return component
	  }
	  /* style inject */
	  
	  /* style inject SSR */
	  

	  
	  var ColorPicker = __vue_normalize__(
	    { render: __vue_render__, staticRenderFns: __vue_staticRenderFns__ },
	    __vue_inject_styles__,
	    __vue_script__,
	    __vue_scope_id__,
	    __vue_is_functional_template__,
	    __vue_module_identifier__,
	    undefined,
	    undefined
	  );

	return ColorPicker;

})));
